<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Spring</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      display: flex;
      align-items: center; /* 垂直居中 */
      justify-content: center; /* 水平居中 */
      /*height: 100vh; /* 使用视口高度作为容器高度 */
    }

    .container {
      max-width: 800px;
      padding: 20px;
      background-color: #f1f1f1;
    }

    h1 {
      margin-top: 0;
    }

    .section {
      margin-bottom: 50px;
    }
  </style>
</head>
<body>
<div class="container">

  <div class="section" id="section2">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>IoC</h2>
    <p>
    <p><strong>介绍：</strong>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。Ioc意味着将你设计好的对象交给容器控制，由容器帮我们查找和注入依赖的对象，对象只是被动的接受所依赖的对象。传统的在你的对象内部直接控制，需要哪个对象就在对象内部new一个需要的对象。</p>

    <p><strong>优点：</strong></p>

    <ol><li>IoC这种思想能帮我们如何设计出高内聚、低耦合的程序。因为在类内部主动创建依赖对象，会导致类与类之间高耦合，如果通过容器来注入需要的对象，对象与对象之间低耦合。</li><li>也方便测试，利于功能复用。</li></ol>

    <p><strong>原理：</strong></p>

    <p>Spring框架通过以下方式实现IoC：</p>

    <ol><li>Bean定义：<strong>在Spring中，通过配置文件（如XML文件）或使用注解来定义Bean。</strong>Bean定义包括Bean的标识符（ID或名称）和相关的配置信息，例如类名、作用域、依赖关系等。</li><li>容器：Spring容器负责创建和管理Bean。它根据Bean定义实例化Bean，并自动解析和注入Bean之间的依赖关系。<strong>Spring容器有两种常用的实现：BeanFactory和ApplicationContext。BeanFactory提供了基本的IoC功能，而ApplicationContext是BeanFactory的扩展，提供了更多的企业级特性，例如国际化、事件传播、资源加载等。</strong></li><li>依赖注入（Dependency Injection）：Spring容器使用依赖注入将Bean的依赖关系注入到对象中。<strong>依赖注入有三种常见的方式：构造函数注入、setter方法注入和接口注入。通过依赖注入</strong>，Spring容器会自动解析和注入依赖的对象，从而实现了对象之间的解耦。</li><li>生命周期管理：Spring容器管理Bean的生命周期，包括创建、初始化和销毁。可以通过配置初始化方法和销毁方法来定义Bean的生命周期回调。</li></ol>

    <p>IoC是spring的核心，贯穿始终。</p>

    </p>
  </div>

  <div class="section" id="section3">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>DI</h2>
    <p>
    <p>依赖注入（Dependency Injection）：通常说依赖注入是IoC的另一种解释，但是我更愿意理解为Spring容器使用依赖注入将Bean的依赖关系注入到对象中。</p>

    <p>依赖注入有三种常见的方式：</p>

    <ol><li>构造函数注入</li><li>setter方法注入</li><li>接口注入</li></ol>

    </p>
  </div>

  <div class="section" id="section4">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>BeanFactory/ApplicationContext</h2>
    <p>
    <p><strong>BeanFactory：</strong>它就是 Spring IoC 容器的真面目。定义了IOC的基本功能，</p>

    <ol><li><strong>有获取实例的getBean方法</strong></li><li><strong>还有判断bean是否存在，是否是单例、原型。</strong></li><li>获取类型、获取别名</li></ol>

    <p><strong>ApplicationContext： </strong>  <strong>ApplicationContext接口继承BeanFactory接口</strong>。提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置实现。</p>

    <p>BeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能</p>

    <p>而ApplicationContext接口<strong>提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展</strong>，相较于BeanFactorty，ApplicationContext还提供了以下的功能： </p>

    <p><strong>国际化支持</strong>：</p>

    <p>Spring的ApplicationContext提供了<strong>国际化支持，使得应用程序可以根据不同的语言和地区，展示相应的文本信息。</strong>这对于开发多语言的应用程序非常有用。</p>

    <p>国际化支持的关键是资源绑定和本地化。Spring通过资源束（ResourceBundle）和MessageSource来实现国际化。资源束是一组本地化的文本资源文件，每个文件对应一个语言和地区。MessageSource是一个接口，定义了获取本地化消息的方法。</p>

    <p>在Spring中，可以通过配置文件或注解来定义资源束和MessageSource，并在应用程序中使用getMessage()方法获取本地化消息。</p>

    <p><strong>事件发布：</strong></p>

    <p>Spring的ApplicationContext提供了事件发布和监听的机制。应用程序可以定义自己的事件，并在适当的时候发布事件，同时可以定义相应的监听器来处理事件。</p>

    <p><strong>AOP集成</strong>：</p>

    <p><strong>Spring的ApplicationContext集成了AOP（面向切面编程）的功能</strong>。AOP允许开发者在不修改原有代码的情况下，通过切入点、切面和通知等概念，实现对系统的横切关注点的统一管理。</p>

    <h3><strong>BeanFactroy和Applicationcontex 区别</strong></h3>

    <ol><li><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p></li><li><p>beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。而 Applicationcontex 主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。</p></li></ol>

    </p>
  </div>

  <div class="section" id="section5">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>AOP</h2>
    <p>
    <p>AOP称为面向切面编程。我们学Java面向对象的时候，如果代码重复了</p>

    <ol><li><p>：抽取成方法</p></li><li><p>：抽取类</p></li></ol>

    <p>但是即使抽取成类还是会出现重复的代码，因为这些逻辑依附在我们业务类的方法逻辑中！AOP的理念：就是将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中！</p>

    <p>没有学Spring AOP之前，我们就可以使用代理来完成。代理可以帮我们增强对象的行为！使用动态代理实质上就是调用时拦截对象方法，对方法进行改造、增强！其实Spring AOP的底层原理就是动态代理！</p>

    <p>JDK动态代理和CGLib动态代理都是Java中常用的实现代理模式的方式。</p>

    <ol><li>JDK动态代理：
      JDK动态代理是通过Java的<strong>反射机制来实现</strong>的。它要求<strong>被代理的类实现一个接口</strong>，并且代理类和被代理类之间有共同的接口。在运行时，JDK动态代理通过创建一个代理类来包装被代理对象，并且代理类实现了被代理接口。通过代理类，可以拦截对被代理对象的方法调用，并在调用前后执行额外的逻辑。JDK动态代理的一个限制是只能代理接口，无法代理类。</li><li>CGLib动态代理：
      <strong>CGLib动态代理是通过继承被代理类来实现的，而不是像JDK动态代理那样要求实现接口。</strong>CGLib动态代理通过生成一个被代理类的子类，并重写被代理类的方法来实现代理。通过继承，CGLib动态代理可以代理非接口类。在运行时，对代理类的方法调用会被重定向到代理类中的代理方法，从而可以在调用前后添加额外的逻辑。</li></ol>

    <p>比较：</p>

    <ul><li>JDK动态代理要求被代理类实现接口，而CGLib动态代理可以代理非接口类。</li><li>JDK动态代理使用Java的反射机制，CGLib动态代理使用继承来实现，<strong>因此CGLib动态代理的性能通常比JDK动态代理略差。</strong></li><li><strong>由于CGLib动态代理是通过继承来实现的，所以无法代理被final修饰的类和方法。</strong></li></ul>

    <p>选择使用JDK动态代理还是CGLib动态代理，取决于具体的需求和场景。如果需要代理接口或者已有的非final类，并且性能要求不是特别高，可以选择JDK动态代理。如果需要代理非接口类或者对性能有较高要求，可以选择CGLib动态代理。</p>

    <p><strong>Spring AOP默认是使用JDK动态代理，如果代理的类没有接口则会使用CGLib代理。</strong></p>

    <p>Spring AOP(面向切面编程)了：<strong>将相同逻辑的重复代码横向抽取出来，使用动态代理技术将这些重复代码织入到目标对象方法中，实现和原来一样的功能。</strong></p>

    <p>这样一来，我们就<strong>在写业务时只关心业务代码，而不用关心与业务无关的代码</strong></p>

    <p>AOP除了有Spring AOP实现外，还有著名的AOP实现者：AspectJ</p>

    <p>AspectJ是语言级别的AOP实现，扩展了Java语言，定义了AOP语法，能够在编译期提供横切代码的织入，所以它有专门的编译器用来生成遵守Java字节码规范的Class文件。</p>

    <p>而Spring借鉴了AspectJ很多非常有用的做法，融合了AspectJ实现AOP的功能。但Spring AOP本质上底层还是动态代理，所以Spring AOP是不需要有专门的编辑器的~</p>

    <p>1.4AOP的术语</p>

    <p><strong>连接点(Join point)：</strong></p>

    <p>能够被拦截的地方：Spring AOP是基于动态代理的，所以是方法拦截的。<strong>每个成员方法都可以称之为连接点</strong>~</p>

    <p><strong>切点(Poincut)：</strong></p>

    <p>具体定位的连接点：上面也说了，<strong>每个方法都可以称之为连接点，我们具体定位到某一个方法就成为切点。</strong></p>

    <p><strong>增强/通知(Advice)：</strong></p>

    <p><strong>表示添加到切点的一段逻辑代码</strong>，并定位连接点的方位信息。</p>

    <p>简单来说就定义了是干什么的，具体是在哪干</p>

    <p>Spring AOP提供了5种Advice类型给我们：前置、后置、返回、异常、环绕给我们使用！</p>

    <p><strong>织入(Weaving)：</strong></p>

    <p>将增强/通知添加到目标类的具体连接点上的过程。</p>

    <p><strong>引入/引介(Introduction)：</strong></p>

    <p>引入/引介允许我们向现有的类添加新方法或属性。是一种特殊的增强！</p>

    <p><strong>切面(Aspect)：</strong></p>

    <p>切面由切点和增强/通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义。</p>

    <p>在《Spring 实战 (第4版)》给出的总结是这样子的：</p>

    <p>通知/增强包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知/增强被应用的具体位置。其中关键的是切点定义了哪些连接点会得到通知/增强。</p>

    </p>
  </div>

  <div class="section" id="section6">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>Spring MVC工作流程</h2>
    <p>
    <ol><li><p>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</p></li><li><p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p></li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li>ViewResolver<code> 会根据逻辑 </code>View<code> 查找实际的 </code>View<code>。</code></li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol>

    </p>
  </div>

  <div class="section" id="section7">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>Bean生命周期</h2>
    <p>
    <p>在Spring容器中，Bean的生命周期包括<strong>实例化、属性填充、初始化和销毁。</strong></p>

    <ol><li><p>实例化Bean：当容器<strong>接收到对尚未初始化的Bean的请求时</strong>，<strong>容器会通过反射创建Bean的实例</strong>。</p></li><li><p>属性填充：<strong>在Bean实例创建后，容器会进行属性填充，将其他Bean作为依赖注入到当前Bean中。</strong></p></li><li><p>初始化Bean：<strong>初始化阶段</strong>包括以下几个步骤：</p><ul><li><p>执行Aware接口的方法：<strong>Spring会检测Bean是否实现了特定的Aware接口</strong>，通过这些接口可以让Bean获取到Spring容器的相关资源，<strong>实现BeanNameAware接口的Bean可以获取自己在Spring容器中的唯一名称。</strong>这个名称可以在Bean初始化过程中被注入，可以在需要时用于记录日志、生成唯一标识符等操作。</p></li><li><strong>执行BeanPostProcessor的前置处理方法</strong>：执行自定义前置处理逻辑。在初始化之前，Spring会调用BeanPostProcessor的<code>postProcessBeforeInitialization()</code>方法，可以进行一些自定义的前置处理逻辑。</li><li><strong>判断Bean是否实现了InitializingBean接口：如果Bean实现了InitializingBean接口，将会调用其<code>afterPropertiesSet()</code>方法来进行初始化。</strong>（数据处理，资源初始化）</li><li>执行用户自定义的初始化方法：通过配置文件或注解，可以指定Bean的初始化方法，如<code>init-method</code>，在这个阶段会执行这些自定义的初始化方法。</li><li><p>执行BeanPostProcessor的后置处理方法：在初始化完成后，Spring会调用BeanPostProcessor的<code>postProcessAfterInitialization()</code>方法，可以进行一些自定义的后置处理逻辑。</p></li></ul></li><li><p>销毁Bean：<strong>当Bean不再需要时，容器会进行销毁操作</strong>，包括以下几个步骤：</p><p><strong>在这个过程也会判断是否实现了某些接口，执行特定的逻辑。</strong></p><ul><li><p>判断Bean是否实现了DestructionAwareBeanPostProcessor接口：如果实现了该接口，容器会调用其销毁回调方法。</p></li><li>判断Bean是否实现了DisposableBean接口：如果实现了该接口，容器会调用其<code>destroy()</code>方法进行销毁操作。</li><li>判断是否配置了自定义的销毁方法：通过配置文件或注解，可以指定Bean的销毁方法，如<code>destroy-method</code>，在这个阶段会自动调用这些自定义的销毁方法。</li></ul></li></ol>

    </p>
  </div>

  <div class="section" id="section8">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>事务介绍</h2>
    <p>
    <p><strong>事务是并发控制的单位，表示一系列操作要么全部完成，要么全部不完成。</strong>它具有ACID四个特性：</p>

    <ol><li><p><strong>原子性（Atomicity）：</strong></p><ul><li><p>事务中的所有操作要么全部完成，要么全部不完成，不会结束在中间某个环节。</p></li></ul></li><li><p><strong>一致性（Consistency）：</strong></p><ul><li><p>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</p></li></ul></li><li><p><strong>事务隔离（Isolation）：</strong></p><ul><li><p>多个事务之间是独立的，不相互影响。</p></li></ul></li><li><p><strong>持久性（Durability）：</strong></p><ul><li>事务处理结束后，对数据的修改是永久的，即便系统故障也不会丢失。</li></ul></li></ol>

    <p><strong>Spring事务是在Spring框架中对事务的实现</strong>。为了保证事务的原子性，Spring提供了事务管理机制。在Spring中，通过声明式事务或编程式事务来实现事务管理。</p>

    <p>为什么需要Spring事务？</p>

    <p>考虑一个简单的例子：银行转账。假设要将<strong>金额从一个账户转移到另一个账户</strong>，这涉及<strong>两个必要的操作</strong>：<strong>将源账户余额减少，将目标账户余额增加。这两个操作要么都成功，要么都失败</strong>，以保持数据一致性。<strong>Spring事务的存在就是为了确保这种操作的原子性。</strong></p>

    <p><strong>Spring事务</strong>本质上是<strong>通过AOP</strong>切面技术，<strong>来实现事务的开始、提交或回滚事务</strong>。</p>

    </p>
  </div>

  <div class="section" id="section9">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>@Transactional</h2>
    <p>
    <p><code>@Transactional</code>是Spring框架中用于<strong>声明事务</strong>的注解。它可以被用在<strong>类</strong>级别和<strong>方法</strong>级别，用于标记一个方法或类需要进行事务管理。</p>

    <p>在方法级别，<code>@Transactional</code>可以用于标记一个方法应该被包装在事务中。在类级别，可以将<code>**@Transactional</code>放在类的声明上<strong>，表示</strong>类的所有公共方法<strong>都应该</strong>被事务管理**。注解可以配置多个属性，以定义事务的各个方面。</p>

    <p>以下是<code>@Transactional</code><strong>注解的一些常用属性</strong>：</p>

    <ol><li><p><strong>propagation（事务传播行为）：</strong></p><ul><li><p>指定事务的传播行为。常用的值包括<code>REQUIRED</code>、<code>REQUIRES_NEW</code>、<code>NESTED</code>等。</p><p><code>java
      @Transactional(propagation = Propagation.REQUIRED)
      public void transactionalMethod() {
      // 业务逻辑
      }
    </code></p></li></ul></li><li><p><strong>isolation（事务隔离级别）：</strong></p><ul><li><p>指定事务的隔离级别。常用的值包括<code>READ_COMMITTED</code>、<code>READ_UNCOMMITTED</code>、<code>SERIALIZABLE</code>等。</p><p><code>java
      @Transactional(isolation = Isolation.READ_COMMITTED)
      public void transactionalMethod() {
      // 业务逻辑
      }
    </code></p></li></ul></li><li><p><strong>readOnly（只读事务）：</strong></p><ul><li><p>指定事务是否为只读。如果设置为<code>true</code>，表示只读事务，不允许对数据进行修改。</p><p><code>java
      @Transactional(readOnly = true)
      public void readOnlyMethod() {
      // 只读业务逻辑
      }
    </code></p></li></ul></li><li><p><strong>timeout（事务超时时间）：</strong></p><ul><li><p>指定事务的超时时间，单位是秒。如果事务在规定的时间内没有完成，将会被回滚。</p><p><code>java
      @Transactional(timeout = 60)
      public void timeoutMethod() {
      // 业务逻辑
      }
    </code></p></li></ul></li><li><p><strong>rollbackFor（回滚的异常类型）：</strong></p><ul><li><p>指定在哪些异常发生时事务应该回滚。可以设置一个或多个异常类型。</p><p><code>java
      @Transactional(rollbackFor = CustomException.class)
      public void transactionalMethod() {
      // 业务逻辑
      }
    </code></p></li></ul></li><li><p><strong>noRollbackFor（不回滚的异常类型）：</strong></p><ul><li><p>指定在哪些异常发生时事务不应该回滚。可以设置一个或多个异常类型。</p><p><code>java
      @Transactional(noRollbackFor = { CustomException1.class, CustomException2.class })
      public void transactionalMethod() {
      // 业务逻辑
      }
    </code></p></li></ul></li></ol>

    <p><code>@Transactional</code>注解提供了丰富的配置选项，可以根据具体的业务需求来设置不同的属性。这样，Spring框架就能够在方法执行前后添加事务管理的逻辑，实现声明式事务管理。</p>

    </p>
  </div>

  <div class="section" id="section10">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>事务失效</h2>
    <p>
    <p><code>@Transactional</code> 注解在以下情况下可能会失效：</p>

    <ol><li><p><strong>非 <code>public</code> 方法：</strong></p><ul><li><p>由于 Spring AOP 是基于接口或者类的子类来创建代理的，所以只有 <code>public</code> 方法才能被代理。非 <code>public</code> 方法上的 <code>@Transactional</code> 注解会被忽略。</p></li></ul></li><li><p><strong>内部方法调用：</strong></p><ul><li><p>当同一类中的一个方法调用另一个有 <code>@Transactional</code> 注解的方法时，事务可能会失效。Spring AOP 默认是通过代理来实现的，而内部方法调用无法触发代理。</p></li></ul></li><li><p><strong>未被 Spring 管理的类：</strong></p><ul><li><p>被 <code>@Transactional</code> 注解标记的方法所在的类必须由 Spring 管理，通常通过注解（如 <code>@Service</code>、<code>@Component</code>）或 XML 配置来确保 Spring 对其进行管理。否则，注解可能不会生效。</p></li></ul></li><li><p><strong>底层数据库不支持事务：</strong></p><ul><li><p>如果底层数据库不支持事务，<code>@Transactional</code> 注解会失效。确保数据库引擎和连接池都支持事务，以及数据库连接的配置正确。</p></li></ul></li><li><p><strong>方法内部自调用：</strong></p><ul><li><p>如果一个方法内部自调用（即 <code>this.method()</code>），并且该方法带有 <code>@Transactional</code> 注解，事务也可能失效。这是因为 Spring AOP 默认是通过代理实现的，内部调用无法触发代理。</p></li></ul></li><li><p><strong><code>@Transactional</code> 注解使用错误：</strong></p><ul><li><p>错误地使用 <code>@Transactional</code> 注解，比如将它放在 <code>private</code> 方法上，或者放在一个没有被 Spring 管理的类上，都可能导致失效。</p></li></ul></li><li><p><strong>异常被吞没：</strong></p><ul><li>如果 <code>@Transactional</code> 注解的方法内部发生异常，但是异常被捕获并且没有重新抛出，事务可能不会回滚。确保异常能够正确传播以触发事务回滚。</li></ul></li></ol>

    <p>总的来说，<code>@Transactional</code> 注解的失效通常与方法的可见性、内部调用、Spring 管理以及数据库事务支持有关。在使用时要注意这些方面，以确保事务按照预期进行。</p>

    </p>
  </div>

  <div class="section" id="section11">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>事务隔离级别</h2>
    <p>
    <p>Spring 提供了五个事务隔离级别，用于控制多个事务之间的相互影响。这些隔离级别定义了一个事务在执行时与其他事务的关系。以下是 Spring 支持的事务隔离级别：</p>

    <ol><li><p><strong>DEFAULT（使用底层数据库的默认隔离级别）：</strong></p><ul><li><p>使用底层数据库的默认隔离级别，例如 MySQL 默认的是 <code>REPEATABLE READ</code>，Oracle 默认的是 <code>READ COMMITTED</code>。</p></li></ul></li><li><p><strong>READ_UNCOMMITTED：</strong></p><ul><li><p>允许一个事务读取另一个事务修改但未提交的数据。最低的隔离级别，可能导致脏读、不可重复读和幻读。</p></li></ul></li><li><p><strong>READ_COMMITTED：</strong></p><ul><li><p>保证一个事务提交后对其他事务可见的数据。防止脏读，但可能会遇到不可重复读和幻读。</p></li></ul></li><li><p><strong>REPEATABLE_READ：</strong></p><ul><li><p>对于相同的查询，保证在同一个事务中多次执行时，结果是一致的。防止脏读和不可重复读，但可能会遇到幻读。</p></li></ul></li><li><p><strong>SERIALIZABLE：</strong></p><ul><li>完全隔离事务，确保事务之间没有交叉。防止脏读、不可重复读和幻读，但可能导致性能下降。</li></ul></li></ol>

    <p>这些隔离级别可以通过 <code>@Transactional</code> 注解的 <code>isolation</code> 属性来设置。例如：</p>

    <p><code>java
      @Transactional(isolation = Isolation.READ_COMMITTED)
      public void myTransactionMethod() {
      // 业务逻辑
      }
    </code></p>

    <p>选择事务隔离级别时，需要根据业务场景和对数据一致性的要求进行权衡。较高的隔离级别通常伴随着较高的性能开销，因此需要根据实际需求进行选择。</p>

    </p>
  </div>

  <div class="section" id="section12">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>事务传播属性</h2>
    <p></p>
  </div>

  <div class="section" id="section13">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>Spring优点</h2>
    <p>
    <p>Spring 框架有许多优点，这些优点使其成为 Java 开发中最流行的框架之一。以下是一些 Spring 框架的主要优点：</p>

    <ol><li><strong>轻量级和非侵入性：</strong><ul><li>Spring 是一个<strong>轻量</strong>级框架，<strong>不需要强制继承特定的类或实现特定的接口</strong>，使得应用的开发更加灵活和非侵入性。</li><li><strong>Spring支持IoC 和 AOP</strong></li></ul></li><li>IoC（控制反转）容器：<ul><li>Spring 提供了 IoC 容器，负责管理应用中的对象的生命周期和配置。通过 IoC，应用对象的创建、销毁和依赖关系的管理都由容器负责，降低了组件之间的耦合度。</li></ul></li><li>AOP（面向切面编程）支持：<ul><li>Spring 支持 AOP 编程，允许将横切关注点（如事务管理、日志记录）与应用主业务逻辑分开，提高了代码的模块化和可维护性。</li></ul></li><li><strong>声明式事务管理：</strong><ul><li><strong>Spring 提供了声明式事务管理</strong>，通过注解或 XML 配置的方式实现事务的声明和管理，简化了事务的编程和管理。</li></ul></li><li><strong>模块化：</strong><ul><li>Spring 是模块化的，提供了众多模块，如数据访问、事务管理、安全性、AOP 等，开发者可以根据需求选择使用，使得应用的构建更加灵活。</li></ul></li><li><strong>集成：</strong><ul><li>Spring 能够与<strong>各种不同的框架和技术集成</strong>，如 MyBatis、Quartz、JUnit 等，提供了更多选择和灵活性。</li></ul></li><li><strong>测试：</strong><ul><li>Spring 框架支持测试，可以通过模拟对象来进行单元测试，提高了代码的可测试性。</li></ul></li><li><strong>简化了 Java 开发：</strong><ul><li>Spring 提供了许多模板和工具，简化了常见任务的开发，如 JDBC 访问、REST 服务等。</li></ul></li><li><strong>强大的社区支持：</strong><ul><li>Spring 拥有庞大的社区支持，有大量的文档、教程和问题解答，开发者可以方便地获取帮助和资源。</li></ul></li></ol>

    <p>这些优点使得 Spring 成为企业级应用开发的首选框架之一。</p>

    </p>
  </div>

  <div class="section" id="section14">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>设计模式</h2>
    <p>
    <p>Spring 框架使用了多种设计模式，其中一些主要的设计模式包括：</p>

    <ol><li><strong>单例模式（Singleton Pattern）：</strong><ul><li>Spring 的 IoC 容器默认采用单例模式，确保在应用中只有一个实例对象。</li></ul></li><li><strong>工厂模式（Factory Pattern）：</strong><ul><li>Spring 使用工厂模式通过 BeanFactory 和 ApplicationContext 创建和管理 Bean 对象。</li></ul></li><li><strong>代理模式（Proxy Pattern）：</strong><ul><li>Spring AOP 使用代理模式实现横切关注点的分离，包括动态代理和静态代理。</li></ul></li></ol>

    <p>这些设计模式使得 Spring 具有高度的灵活性、可扩展性和可维护性。Spring 通过合理使用这些设计模式，提供了一种模块化、可测试、松耦合的开发方式。</p>

    </p>
  </div>

  <div class="section" id="section15">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>HashMap添加元素</h2>
    <p></p>
  </div>
</div>
</body>
</html>