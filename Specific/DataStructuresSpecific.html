<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>数据结构与算法</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      display: flex;
      align-items: center; /* 垂直居中 */
      justify-content: center; /* 水平居中 */
      /*height: 100vh; /* 使用视口高度作为容器高度 */
    }

    .container {
      max-width: 800px;
      padding: 20px;
      background-color: #f1f1f1;
    }

    h1 {
      margin-top: 0;
    }

    .image {
      max-width: 800px;
    }

    .section {
      margin-bottom: 50px;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="section" id="section1">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>排序算法总览</h2>
    <div>
      <img src="Img/sort.png" alt="" class="image">
    </div>
  </div>

  <div class="section" id="section2">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>冒泡排序</h2>
    <p>
    <p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地比较相邻的元素并交换位置，将最大（或最小）的元素逐渐“冒泡”到数组的末尾（或开头）。具体步骤如下：</p>

    <ol><li>从数组的第一个元素开始，依次比较当前元素和其相邻的下一个元素。</li><li>如果当前元素大于（或小于）相邻元素，交换它们的位置。</li><li>继续向后遍历，对每一对相邻元素进行比较和交换，直到遍历到数组的倒数第二个元素。</li><li>重复执行上述步骤，每一轮都能将最大（或最小）的元素“冒泡”到正确的位置。</li><li>经过 n-1 轮的比较和交换后，整个数组就会变得有序。</li></ol>

    <p>冒泡排序的时间复杂度为 O(n^2)，其中 n 是数组的长度。尽管冒泡排序是一种简单直观的排序算法，但它的性能相对较低，不适用于大规模数据的排序。</p>

    </p>
  </div>

  <div class="section" id="section3">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>HashMap添加元素</h2>
    <p></p>
  </div>

  <div class="section" id="section4">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>HashMap添加元素</h2>
    <p></p>
  </div>
</div>
</body>
</html>