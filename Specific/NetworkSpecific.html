<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>计网</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      display: flex;
      align-items: center; /* 垂直居中 */
      justify-content: center; /* 水平居中 */
      /*height: 100vh; /* 使用视口高度作为容器高度 */
    }

    .image {
      max-width: 800px;
    }

    .container {
      max-width: 800px;
      padding: 20px;
      background-color: #f1f1f1;
    }

    h1 {
      margin-top: 0;
    }

    .section {
      margin-bottom: 50px;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="section" id="section1">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>HTTP及原理</h2>
    <p>
    <p>HTTP（Hypertext Transfer Protocol）是一种用于在网络上<strong>传输超文本</strong>的协议。它是一种<strong>无状态</strong>的协议，意味着每个请求从客户端到服务器的传输都是独立的，<strong>服务器不会保存</strong>任何关于<strong>之前请求的信息</strong>。</p>

    <p>在更简单的说法中，<strong>HTTP就是</strong>一种<strong>规定</strong>了<strong>浏览器</strong>（客户端）和<strong>服务器之间如何传输信息的协议</strong>。它建立在客户端和服务器之间的请求-响应模型上，其中<strong>客户端发送请求</strong>，<strong>服务器返回响应</strong>。</p>

    <p>HTTP的工作原理如下：</p>

    <ol><li><p><strong>建立连接：</strong> 客户端通过一个 URL（Uniform Resource Locator）<strong>指定要访问的资源</strong>，然后发起与服务器的连接。</p></li><li><p><strong>发起请求：</strong> 客户端向服务器发送请求，请求中包含了要执行的动作（比如获取一个网页、提交表单等）和请求的资源地址。</p></li><li><p><strong>服务器处理请求：</strong> <strong>服务器</strong>收到请求后，<strong>会根据请求的内容进行相应的处理</strong>，可能涉及到查询数据库、读取文件等。</p></li><li><p><strong>服务器发送响应：</strong> <strong>服务器将处理结果</strong>以响应的形式<strong>返回给客户端</strong>。响应包括一个状态码，用于表示请求是否成功，以及实际的数据。</p></li><li><p><strong>关闭连接：</strong> 客户端接收到服务器的响应后，连接可以被关闭，请求-响应过程完成。</p></li></ol>

    <p>HTTP协议通常<strong>使用TCP</strong>（Transmission Control Protocol）<strong>作为它的传输层协议</strong>，确保数据的可靠传输。</p>

    <p>总的来说，HTTP是使得在互联网上传输超文本（例如网页）成为可能的基础协议，它定义了客户端和服务器之间如何通信的规则，使得我们能够通过浏览器获取和展示网页内容。</p>

    </p>
  </div>

  <div class="section" id="section2">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>无状态性</h2>
    <p>
    <p>HTTP（Hypertext Transfer Protocol）协议是一种应用层协议，用于在客户端和服务器之间传输超文本数据。其中，<strong>HTTP的无状态性（Stateless）是指服务器在处理请求时不会存储客户端的状态信息。</strong></p>

    <p>具体来说，HTTP的<strong>无状态性意味着每个请求都是独立的</strong>，服务器不会保存先前请求的任何状态信息，也<strong>不会知道两个请求是否来自同一客户端</strong>。<strong>每个请求都是相互独立的事件，服务器仅根据当前请求的内容进行处理和响应。</strong></p>

    <p>这种无状态性带来了以下几个特点：</p>

    <ol><li><p><strong>简化服务器的设计</strong>：由于服务器不需要维护客户端的状态信息，因此<strong>服务器可以更加简单</strong>，不需要存储和管理大量的状态数据。</p></li><li><p><strong>可扩展性</strong>：由于服务器不需要维护状态，它可以<strong>更轻松地处理大量并发请求</strong>，从而提高系统的可扩展性。</p></li><li><p><strong>缺乏上下文信息</strong>：由于无状态性，服务器在处理每个请求时无法获得先前请求的上下文信息。因此，<strong>如果需要在多个请求之间共享状态，需要在每个请求中显式地传递相关的上下文信息</strong>。</p></li></ol>

    <p><strong>为了实现状态的保持和跟踪，HTTP引入了一些机制，如Cookie和Session。通过使用Cookie，服务器可以在响应中向客户端发送一个标识符，客户端在后续的请求中会携带该标识符，从而实现状态的跟踪和保持。服务器可以根据这个标识符来识别客户端，并在服务器端维护相关的状态信息。</strong></p>

    <p>总之，HTTP的无状态性意味着每个请求都是独立的，服务器不会保存客户端的状态信息。这种设计简化了服务器的实现和维护，但也需要额外的机制来处理状态的保持和跟踪。</p>

    </p>
  </div>

  <div class="section" id="section3">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>GET/POST</h2>
    <p>
    <p>POST 和 GET 是 HTTP 协议中最常见的两种请求方法，它们在传递数据和使用方式上有一些明显的区别：</p>

    <ol><li><strong>数据传递方式：</strong><ul><li><strong>GET：</strong> 将<strong>请求数据加在 URL 后</strong>，以查询字符串的形式传递。<strong>数据在 URL 中可见</strong>，<strong>不适合传递账号密码这样的敏感信息</strong>。<strong>适合传递数据量较小的数据。</strong></li><li><strong>POST：</strong> 将<strong>请求数据放在请求体body中</strong>，<strong>在URL中不可见</strong>。适用于传递较<strong>大量的数据</strong>，也<strong>更为安全</strong>。</li></ul></li><li><strong>使用场景：</strong><ul><li><strong>GET：</strong> <strong>适用于请求读</strong>取操作，如<strong>获取页面</strong>、搜索等。因为数据附加在 URL 中，可以被书签保存。</li><li><strong>POST：</strong> <strong>适用于请求写</strong>入操作，如<strong>提交表单</strong>、上传文件等。因为数据在请求体中，更适合传递复杂的结构化数据。</li></ul></li><li><strong>可缓存性：</strong><ul><li><strong>GET：</strong> 请求可被缓存，可以被浏览器缓存起来，适用于幂等操作（多次执行产生相同结果的操作）。</li><li><strong>POST：</strong> 请求不能被缓存，适用于非幂等操作，每次执行可能产生不同结果。</li></ul></li></ol>

    <p>总体而言，选择使用 GET 还是 POST 取决于具体的需求。GET 更适合获取数据，而 POST 更适合提交数据。</p>

    </p>
  </div>

  <div class="section" id="section4">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>TCP/UDP</h2>
    <p>
    <p><strong>是否面向连接</strong>：<strong>UDP</strong> 在传送数据之前<strong>不需要先建立连接</strong>。而 <strong>TCP</strong> 提供<strong>面向连接</strong>的服务，在<strong>传送数据之前必须先建立连接，数据传送结束后要释放连接</strong>。</p>

    <p><strong>是否是可靠传输</strong>：<strong>服务器收到 UDP 报文后</strong>，<strong>不需要</strong>给出任何<strong>确认</strong>，并且<strong>不保证数据不丢失</strong>，不保证是否顺序到达。TCP 提供<strong>可靠的传输服务</strong>，<strong>TCP 在传递数据之前，会有三次握手来建立连接</strong>，而且<strong>在数据传递时</strong>，<strong>有确认</strong>、窗口、重传、拥塞控制<strong>机制</strong>。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p>

    <p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。<strong>TCP</strong> 传输是<strong>有状态的</strong>，这个有状态说的是 <strong>TCP 会去记录</strong>自己<strong>发送消息的状态比如消息是否发送</strong>了、<strong>是否被接收</strong>了等等。为此 ，TCP 需要维持复杂的连接状态表。而 <strong>UDP 是无状态</strong>服务，简单来说就是不管发出去之后的事情了。</p>

    <p><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p>

    <p><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</p>

    <p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p>

    <p><strong>是否提供广播或多播服务</strong>：<strong>TCP 只支持点对点通信</strong>，<strong>UDP 支持一对一、一对多、多对一、多对多</strong>；</p>

    </p>
  </div>

  <div class="section" id="section5">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>三握三挥</h2>
    <p>
    <p><strong>TCP是面向连接的协议，在正式传输数据之前要做好两端之间的准备，需要发送总共三个报文来完成连接的建立。</strong></p>

    <h3>三次握手（Three-Way Handshake）</h3>

    <ol><li><strong>第一次握手（SYN）：</strong><ul><li><strong>客户端向服务器发送一个标志位</strong>（SYN seq = x），表示客户端请求建立连接。</li></ul></li><li><strong>第二次握手（SYN + ACK）：</strong><ul><li><strong>服务器接收到客户端的请求</strong>，<strong>向客户端发送一个确认（ACK = x + 1）</strong>和<strong>自己的标志位（SYN seq = y）</strong>。</li></ul></li><li><strong>第三次握手（ACK）：</strong><ul><li><strong>客户端接收到服务器的确认，向服务器发送一个确认</strong>（ACK = y + 1）。</li></ul></li></ol>

    <p><strong>为什么不是两次</strong>：为什么是三次而不是两次，因为是<strong>两次无法确认客户端的接收能力</strong>。客户端向服务端发送一个请求，服务端给出一个响应，这个时候就认为连接已经建立，这就是两次握手，服务端单方面的认为连接已经建立，但是客户端在发送一个请求之后就再也不管了，不管服务端是否响应，客户端都不再做出反应。<strong>TCP是面向连接</strong>的，这个连接是<strong>面向连接双方</strong>的，<strong>只有两次握手，只有服务端单方面的认为连接成功。</strong></p>

    <p><strong>为什么不是四次</strong>：三次就可以完成你对我和我对你之间连接的确认，次数更多只是资源的浪费。</p>

    <h3>四次挥手（Four-Way Handshake）</h3>

    <p><strong>TCP的四次挥手是为了终止一个TCP连接，作为客户端和服务端需要总共发送四个报文用来确认连接已经断开</strong></p>

    <ol><li><strong>第一次挥手（FIN）：</strong><ul><li><strong>当客户端或服务器某一方决定关闭连接</strong>时，<strong>发送一个关闭请求给对方</strong>。这里以客户端发送关闭请求为例。</li></ul></li><li><strong>第二次挥手（ACK）：</strong><ul><li><strong>接收到关闭请求的一方发送一个确认（ACK）给对方。</strong></li></ul></li><li><strong>第三次挥手（FIN）：</strong><ul><li><strong>服务端接收到关闭请求后，决定也关闭连接，向发起关闭请求的一方发送一个关闭请求</strong>（FIN）。</li></ul></li><li><strong>第四次挥手（ACK）：</strong><ul><li><strong>客户端接收到关闭请求后发送一个确认（ACK）给对方</strong>。</li><li>这个时候连接关闭。</li></ul></li></ol>

    <p>主要涉及到 <strong>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</strong></p>

    <p>因为<strong>服务器收到客户端断开连接的请求时，可能还有一些数据没有发完</strong>，这时<strong>先回复 ACK</strong>，<strong>表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</strong></p>

    </p>
  </div>

  <div class="section" id="section6">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>状态码</h2>
    <p>
    <p>HTTP协议中，状态码（Status Code）是服务器对请求的处理结果的<strong>三位数字</strong>代码。HTTP状态码主要<strong>分为五大类</strong>，每个类别有一些常见的状态码，其中以2xx、3xx、4xx和5xx为主要类别。</p>

    <p>HTTP协议常见的状态码主要分为五个类别，每个类别有一些常见的状态码。以下是常见的HTTP状态码：</p>

    <ol><li><p><strong>1xx（信息性状态码）：</strong></p><ul><li>100 Continue：客户端应继续其请求。</li><li><p>101 Switching Protocols：服务器已经理解并接受了客户端的请求，要求客户端切换协议。</p></li></ul></li><li><p><strong>2xx（成功状态码）：</strong></p><ul><li><strong>200 OK：请求成功。</strong></li><li>201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。</li><li><p>204 No Content：服务器成功处理了请求，但没有返回任何内容。</p></li></ul></li><li><p><strong>3xx（重定向状态码）：</strong></p><ul><li>300 Multiple Choices：被请求的资源有一系列可供选择的回馈信息，用户或浏览器能够自行选择一个首选的地址进行重定向。</li><li>301 Moved Permanently：请求的资源已被永久移动到新URI。</li><li><p>302 Found：请求的资源临时从不同的URI响应请求。</p></li></ul></li><li><p><strong>4xx（客户端错误状态码）：</strong></p><ul><li>400 Bad Request：请求无效，服务器不理解请求的语法。</li><li>401 Unauthorized：请求要求身份验证。</li><li>403 Forbidden：服务器拒绝请求。</li><li><p><strong>404 Not Found：服务器找不到请求的资源。</strong></p></li></ul></li><li><p><strong>5xx（服务器错误状态码）：</strong></p><ul><li><strong>500 Internal Server Error：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</strong></li><li>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 Service Unavailable：服务器暂时的无法处理请求，通常是由于维护或者过载。</li></ul></li></ol>

    <p>这些状态码用于标识 HTTP 请求和响应的处理状态，帮助客户端了解请求的结果并采取相应的操作。在实际开发中，理解这些状态码对于排查问题和优化网络请求非常重要。</p>

    </p>
  </div>

  <div class="section" id="section7">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>HTTPS</h2>
    <p>
    <p>HTTPS（Hypertext Transfer Protocol Secure）<strong>超文本传输协议</strong>。在通俗的语言中，你可以把<strong>HTTPS看作是HTTP的加强版</strong>，<strong>HTTP协议不适合传输一些敏感信息</strong>，比如：各种<strong>账号、密码</strong>等信息它加入了一些安全性的措施，让你在浏览网页或进行在线交易时<strong>更加安全</strong>。</p>

    <p>现在，我们来看看HTTPS是如何工作的：</p>

    <ol><li><p><strong>数据加密：</strong> 最显著的一个特点就是数据加密。当你在使用HTTPS浏览网页时，你的数据会被加密，这意味着<strong>即使有人截取了你的通信</strong>，他们也<strong>无法轻松地解读你的数据</strong>。这就增加了用户的隐私和安全性。</p></li><li><p><strong>身份验证：</strong> HTTPS还提供了对网站身份的验证。这意味着你能够确信你连接到的是真正的网站，而不是一个恶意的仿冒网站。这一点对于在线购物、银行等涉及个人信息和金钱的活动至关重要。</p></li><li><p><strong>数据完整性：</strong> HTTPS确保你在浏览或与网站互动时传输的数据没有被篡改。这就意味着在你提交表单或进行在线支付时，你的信息将完整、未被修改地传达到目的地。</p></li></ol>

    <p>HTTPS的实现基于SSL/TLS协议，它在HTTP和TCP之间添加了一层安全性的协议。通过使用数字证书、加密算法和其他安全措施，HTTPS在保障通信隐私的同时，也能够有效防范网络攻击和信息泄露。</p>

    <p>总而言之，HTTPS是为了让你在互联网上的各种活动更加安全，保护你的隐私和个人信息而设计的一种协议。</p>

    </p>
  </div>

  <div class="section" id="section8">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>7层模型</h2>
    <p>
    <div>
      <img src="Img/protocol.png" alt="" class="image">
    <ol><li><p><strong>物理层（Physical Layer）：</strong></p><ul><li><p><strong>协议：</strong> 例如Ethernet、USB、DSL等。</p></li><li><p><strong>作用：</strong>   物理层是最底层的层次，通过双绞线或者同轴电缆来传输二进制电信号</p></li></ul></li><li><p><strong>数据链路层（Data Link Layer）：</strong></p><ul><li><p><strong>协议：</strong> 以太网（Ethernet）、PPP（Point-to-Point Protocol）、HDLC（High-Level Data Link Control）等。</p></li><li><p><strong>作用：</strong> 相当于信封的作用，它把数据封装成一个帧（加上地址和控制信息），就像我们把信装进信封里。</p></li></ul></li><li><p><strong>网络层（Network Layer）：</strong></p><ul><li><p><strong>协议：</strong> IP（Internet Protocol）、ICMP（Internet Control Message Protocol）、OSPF（Open Shortest Path First）等。</p></li><li><p><strong>作用：</strong>  就像邮局一样，负责将带有地址的信封发送到目标地址。</p></li></ul></li><li><p><strong>传输层（Transport Layer）：</strong></p><ul><li><p><strong>协议：</strong> TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）。</p></li><li><p><strong>作用：</strong>就像邮递员把信件正确的送到收件人手中。</p></li></ul></li><li><p><strong>会话层（Session Layer）：</strong></p><ul><li><p><strong>协议：</strong> NetBIOS（Network Basic Input/Output System）、RPC（Remote Procedure Call）。</p></li><li><p><strong>作用：</strong> 会话负责管理会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。   </p><p>类似于写信时的格式规定，会话层规定了通信的格式，例如如何开始和结束一封信，就像我们在信中使用的问候语和结束语一样。</p></li></ul></li><li><p><strong>表示层（Presentation Layer）：</strong></p><ul><li><p><strong>协议：</strong> SSL/TLS（Secure Sockets Layer/Transport Layer Security）。</p></li><li><p><strong>作用：对数据进行编码和转换</strong>功能,  就像是对信中的文字进行翻译，确保发送方和接收方能够正确的理解，处理数据的格式，就像是写信规范。</p></li></ul></li><li><p><strong>应用层（Application Layer）：</strong></p><ul><li><p><strong>协议：</strong> HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。</p></li><li><strong>作用：</strong>  直接为应用提供网络服务。处理邮寄信件或者邮递物品这样一个需求。</li></ul></li></ol>

    <p>这些层次组成了OSI模型，每一层都有特定的职责，使得网络通信在不同层次上能够更好地进行管理和维护。</p>
    </div>

    </p>
  </div>

  <div class="section" id="section9">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>TCP完整过程</h2>
    <p>
    <p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输层协议。以下是TCP协议的基本过程：</p>

    <ol><li><p><strong>建立连接（三次握手）：</strong></p><ul><li><strong>客户端向服务器发送SYN报文（同步序列编号）。</strong></li><li><strong>服务器收到SYN报文后，回复一个SYN+ACK报文。</strong></li><li><strong>客户端再回复一个ACK报文。</strong></li><li><p>这样，连接就建立起来了。</p></li></ul></li><li><p><strong>数据传输：</strong></p><ul><li><strong>建立连接后，双方可以开始传输数据。</strong></li><li><strong>数据被切分成小的数据段，每个数据段携带序列号。</strong></li><li><p><strong>接收方收到数据后发送ACK报文，通知发送方已经收到，并指定下一个期望接收的序列号。</strong></p></li></ul></li><li><p><strong>流量控制：</strong></p><ul><li><strong>TCP使用滑动窗口机制进行流量控制。</strong></li><li><strong>接收方通过通告窗口大小来告诉发送方自己的接收能力。</strong></li><li><p><strong>发送方根据接收方的窗口大小来控制发送的数据量，以防止溢出。</strong></p></li></ul></li><li><p><strong>拥塞控制：</strong></p><ul><li><strong>TCP通过拥塞窗口和慢启动等算法来进行拥塞控制。</strong></li><li><strong>如果网络拥塞，TCP会减小拥塞窗口，限制发送速率。</strong></li><li><p><strong>若网络畅通，TCP会逐渐增大拥塞窗口，提高发送速率。</strong></p></li></ul></li><li><p><strong>关闭连接（四次挥手）：</strong></p><ul><li><strong>其中一方发送FIN报文，表示不再发送数据。</strong></li><li><strong>对方接收到FIN后，回复一个ACK报文。</strong></li><li><strong>对方再发送一个FIN报文。</strong></li><li><strong>收到FIN后，回复一个ACK报文，连接关闭。</strong></li></ul></li></ol>

    <p>这就是TCP的基本过程。三次握手和四次挥手确保了连接的可靠建立和可靠关闭，而流量控制和拥塞控制则确保了在传输过程中的高效性和稳定性。</p>

    </p>
  </div>

  <div class="section" id="section10">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>UDP完整过程</h2>
    <p>
    <p>UDP（User Datagram Protocol）是一种面向无连接的传输层协议，不保证数据传输的可靠性。以下是UDP的基本过程：</p>

    <ol><li><p><strong>数据封装：</strong></p><ul><li>应用层将数据封装成UDP数据包（UDP Datagram）。</li><li><p>数据包包含源端口、目标端口、长度和校验和等信息。</p></li></ul></li><li><p><strong>数据传输：</strong></p><ul><li>不像TCP那样需要先建立连接，UDP是无连接的，因此可以直接发送数据。</li><li><p>UDP将数据包发送到网络上，不保证数据的可靠性和顺序性。</p></li></ul></li><li><p><strong>数据接收：</strong></p><ul><li>接收方的UDP层接收到数据包，提取出数据。</li><li><p>数据包中的目标端口信息帮助将数据交给正确的应用程序。</p></li></ul></li><li><p><strong>无连接性：</strong></p><ul><li><p>由于UDP是无连接的，因此不进行握手和挥手的过程。没有建立连接和释放连接的过程，通信双方可以独立地发送和接收数据包。</p></li></ul></li><li><p><strong>无拥塞控制：</strong></p><ul><li><p>UDP不提供拥塞控制机制。发送方不会根据网络情况动态调整发送速率，因此可能导致网络拥塞。</p></li></ul></li><li><p><strong>校验和：</strong></p><ul><li><p>UDP在数据包中包含了校验和字段，但仅用于发现传输过程中是否发生了数据损坏，而不会进行数据的恢复。</p></li></ul></li><li><p><strong>适用场景：</strong></p><ul><li>由于其轻量和低开销的特点，UDP适用于对实时性要求高、可以容忍一些数据丢失的场景，比如音频、视频传输，DNS查询等。</li></ul></li></ol>

    <p>总的来说，UDP是一种简单、轻量的协议，适用于对实时性要求高、可以容忍一定数据丢失的应用场景。但由于其不保证可靠性和无连接性，对于需要可靠传输的场景，通常选择使用TCP。</p>

    </p>
  </div>

  <div class="section" id="section11">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>输入URL后</h2>
    <p>
    <p>在浏览器中输入URL后：</p>

    <ol><li><p><strong>URL解析：</strong></p><ul><li><p>浏览器首先<strong>对输入的URL进行解析</strong>，<strong>提取出</strong>协议（通常是HTTP或HTTPS）、域名、端口号、路径等信息。</p></li></ul></li><li><p><strong>DNS解析：</strong></p><ul><li><p>浏览器通过域名系统（DNS）<strong>将域名解析成对应的IP地址</strong>，找到相应服务器的位置。</p></li><li><p>因为，<strong>域名比 IP 地址更好记</strong>，更习惯在浏览器<strong>输入域名而不是 IP</strong>， 通过IP 地址才能找到对应的主机，因而首先<strong>需要将一个域名转化为相应的 IP 地址</strong>，这就是 DNS 协议所要做的事。</p><p>DNS <strong>就像我们手机中的通讯录一样</strong>，通讯录中<strong>备注的是对方的姓名</strong>（类似于域名），但是<strong>打电话的时候实际需要的是电话号码</strong>（类似于 IP 地址），利用<strong>通讯录会姓名转化为对应的电话号码</strong>。</p></li></ul></li><li><p><strong>建立TCP连接：</strong></p><ul><li><p><strong>客户端和服务器通过三次握手建立TCP连接</strong></p></li><li><p><em>浏览器通过使用HTTP或HTTPS协议与服务器建立TCP连接。</em></p></li></ul></li><li><p><strong>发送HTTP请求：</strong></p><ul><li><p><strong>浏览器发送请求信息</strong></p></li><li><p>浏览器会给服务器发送一个 HTTP 请求报文，请求报文包括请求行、请求头、请求空行和请求体。在请求行中会指定方法、资源路径以及 HTTP 版本，其中资源路径是指定所要操作资源在服务器中的位置，而方法是指定要对这个资源做什么样的操作。</p></li></ul></li><li><p><strong>服务器处理请求：</strong></p><ul><li><p><strong>服务器接收到请求后，根据请求的路径和参数进行处理</strong>，可能涉及到动态生成内容、数据库查询等操作。</p></li></ul></li><li><p><strong>服务器返回HTTP响应：</strong></p><ul><li><p><strong>服务器将相应信息发送给客户端。</strong></p></li><li><p>当收到浏览器发送的请求报文后，服务器会对此请求报文进行相应的处理，并返回响应报文给浏览器。比如请求报文想要获取（GET） index.html 这个文件，那么服务器就会找到 index.html 文件，然后将此文件作为响应报文中的响应体发送给浏览器。</p><p>响应报文包括响应行、响应头、响应空行和响应体。在响应行中会指定 HTTP 版本、状态码和对状态码的解释信息，比如 HTTP/1.1 200 OK ，其中 200 是响应码，指请求被正常处理，也就是成功 OK 的意思。</p></li></ul></li><li><p><strong>浏览器接收响应：</strong></p><ul><li><p><strong>客户端浏览器接收相应。</strong></p></li><li><p>浏览器接收到HTTP响应后，根据响应头部的信息判断响应是否成功，如果是HTML内容，则开始渲染页面。</p></li></ul></li><li><p><strong>显示页面：</strong></p><ul><li><p><strong>如果需要显示的话，浏览器会把页面显示到屏幕上。</strong></p></li><li><p>最终，浏览器将渲染后的页面显示在用户的屏幕上。</p></li></ul></li><li><p>#### 断开连接</p><p>当数据完成请求到返回的过程之后，根据请求/相应头中 Connection 的 Keep-Alive 属性可以选择是否断开 TCP 连接，如果不需要再进行数据通信，即可以关闭连接，此时则会发生<strong>四次挥手</strong>行为。</p></li></ol>

    <p>以上步骤是一个简化的过程，实际上，浏览器还会处理一些附加的工作，如处理JavaScript、处理缓存、处理重定向、处理Cookie等。整个过程是多个子系统协同工作的结果，以确保用户在浏览器中输入URL后获得一个可视化的、交互式的页面。</p>

    </p>
  </div>

  <div class="section" id="section12">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>HashMap添加元素</h2>
    <p></p>
  </div>
</div>
</body>
</html>