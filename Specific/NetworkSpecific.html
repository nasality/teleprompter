<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>计网</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      display: flex;
      align-items: center; /* 垂直居中 */
      justify-content: center; /* 水平居中 */
      /*height: 100vh; /* 使用视口高度作为容器高度 */
    }

    .container {
      max-width: 800px;
      padding: 20px;
      background-color: #f1f1f1;
    }

    h1 {
      margin-top: 0;
    }

    .section {
      margin-bottom: 50px;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="section" id="section1">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>HTTP及原理</h2>
    <p>
    <p>HTTP（Hypertext Transfer Protocol）是一种用于在网络上<strong>传输超文本</strong>的协议。它是一种<strong>无状态</strong>的协议，意味着每个请求从客户端到服务器的传输都是独立的，<strong>服务器不会保存</strong>任何关于<strong>之前请求的信息</strong>。</p>

    <p>在更简单的说法中，<strong>HTTP就是</strong>一种<strong>规定</strong>了<strong>浏览器</strong>（客户端）和<strong>服务器之间如何传输信息的协议</strong>。它建立在客户端和服务器之间的请求-响应模型上，其中<strong>客户端发送请求</strong>，<strong>服务器返回响应</strong>。</p>

    <p>HTTP的工作原理如下：</p>

    <ol><li><p><strong>建立连接：</strong> 客户端通过一个 URL（Uniform Resource Locator）<strong>指定要访问的资源</strong>，然后发起与服务器的连接。</p></li><li><p><strong>发起请求：</strong> 客户端向服务器发送请求，请求中包含了要执行的动作（比如获取一个网页、提交表单等）和请求的资源地址。</p></li><li><p><strong>服务器处理请求：</strong> <strong>服务器</strong>收到请求后，<strong>会根据请求的内容进行相应的处理</strong>，可能涉及到查询数据库、读取文件等。</p></li><li><p><strong>服务器发送响应：</strong> <strong>服务器将处理结果</strong>以响应的形式<strong>返回给客户端</strong>。响应包括一个状态码，用于表示请求是否成功，以及实际的数据。</p></li><li><p><strong>关闭连接：</strong> 客户端接收到服务器的响应后，连接可以被关闭，请求-响应过程完成。</p></li></ol>

    <p>HTTP协议通常<strong>使用TCP</strong>（Transmission Control Protocol）<strong>作为它的传输层协议</strong>，确保数据的可靠传输。</p>

    <p>总的来说，HTTP是使得在互联网上传输超文本（例如网页）成为可能的基础协议，它定义了客户端和服务器之间如何通信的规则，使得我们能够通过浏览器获取和展示网页内容。</p>

    </p>
  </div>

  <div class="section" id="section2">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>无状态性</h2>
    <p>
    <p>HTTP（Hypertext Transfer Protocol）协议是一种应用层协议，用于在客户端和服务器之间传输超文本数据。其中，<strong>HTTP的无状态性（Stateless）是指服务器在处理请求时不会存储客户端的状态信息。</strong></p>

    <p>具体来说，HTTP的<strong>无状态性意味着每个请求都是独立的</strong>，服务器不会保存先前请求的任何状态信息，也<strong>不会知道两个请求是否来自同一客户端</strong>。<strong>每个请求都是相互独立的事件，服务器仅根据当前请求的内容进行处理和响应。</strong></p>

    <p>这种无状态性带来了以下几个特点：</p>

    <ol><li><p><strong>简化服务器的设计</strong>：由于服务器不需要维护客户端的状态信息，因此<strong>服务器可以更加简单</strong>，不需要存储和管理大量的状态数据。</p></li><li><p><strong>可扩展性</strong>：由于服务器不需要维护状态，它可以<strong>更轻松地处理大量并发请求</strong>，从而提高系统的可扩展性。</p></li><li><p><strong>缺乏上下文信息</strong>：由于无状态性，服务器在处理每个请求时无法获得先前请求的上下文信息。因此，<strong>如果需要在多个请求之间共享状态，需要在每个请求中显式地传递相关的上下文信息</strong>。</p></li></ol>

    <p><strong>为了实现状态的保持和跟踪，HTTP引入了一些机制，如Cookie和Session。通过使用Cookie，服务器可以在响应中向客户端发送一个标识符，客户端在后续的请求中会携带该标识符，从而实现状态的跟踪和保持。服务器可以根据这个标识符来识别客户端，并在服务器端维护相关的状态信息。</strong></p>

    <p>总之，HTTP的无状态性意味着每个请求都是独立的，服务器不会保存客户端的状态信息。这种设计简化了服务器的实现和维护，但也需要额外的机制来处理状态的保持和跟踪。</p>

    </p>
  </div>

  <div class="section" id="section3">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>GET/POST</h2>
    <p>
    <p>POST 和 GET 是 HTTP 协议中最常见的两种请求方法，它们在传递数据和使用方式上有一些明显的区别：</p>

    <ol><li><strong>数据传递方式：</strong><ul><li><strong>GET：</strong> 将<strong>请求数据加在 URL 后</strong>，以查询字符串的形式传递。<strong>数据在 URL 中可见</strong>，<strong>不适合传递账号密码这样的敏感信息</strong>。<strong>适合传递数据量较小的数据。</strong></li><li><strong>POST：</strong> 将<strong>请求数据放在请求体body中</strong>，<strong>在URL中不可见</strong>。适用于传递较<strong>大量的数据</strong>，也<strong>更为安全</strong>。</li></ul></li><li><strong>使用场景：</strong><ul><li><strong>GET：</strong> <strong>适用于请求读</strong>取操作，如<strong>获取页面</strong>、搜索等。因为数据附加在 URL 中，可以被书签保存。</li><li><strong>POST：</strong> <strong>适用于请求写</strong>入操作，如<strong>提交表单</strong>、上传文件等。因为数据在请求体中，更适合传递复杂的结构化数据。</li></ul></li><li><strong>可缓存性：</strong><ul><li><strong>GET：</strong> 请求可被缓存，可以被浏览器缓存起来，适用于幂等操作（多次执行产生相同结果的操作）。</li><li><strong>POST：</strong> 请求不能被缓存，适用于非幂等操作，每次执行可能产生不同结果。</li></ul></li></ol>

    <p>总体而言，选择使用 GET 还是 POST 取决于具体的需求。GET 更适合获取数据，而 POST 更适合提交数据。</p>

    </p>
  </div>

  <div class="section" id="section4">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>TCP/UDP</h2>
    <p>
    <p><strong>是否面向连接</strong>：<strong>UDP</strong> 在传送数据之前<strong>不需要先建立连接</strong>。而 <strong>TCP</strong> 提供<strong>面向连接</strong>的服务，在<strong>传送数据之前必须先建立连接，数据传送结束后要释放连接</strong>。</p>

    <p><strong>是否是可靠传输</strong>：<strong>服务器收到 UDP 报文后</strong>，<strong>不需要</strong>给出任何<strong>确认</strong>，并且<strong>不保证数据不丢失</strong>，不保证是否顺序到达。TCP 提供<strong>可靠的传输服务</strong>，<strong>TCP 在传递数据之前，会有三次握手来建立连接</strong>，而且<strong>在数据传递时</strong>，<strong>有确认</strong>、窗口、重传、拥塞控制<strong>机制</strong>。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p>

    <p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。<strong>TCP</strong> 传输是<strong>有状态的</strong>，这个有状态说的是 <strong>TCP 会去记录</strong>自己<strong>发送消息的状态比如消息是否发送</strong>了、<strong>是否被接收</strong>了等等。为此 ，TCP 需要维持复杂的连接状态表。而 <strong>UDP 是无状态</strong>服务，简单来说就是不管发出去之后的事情了。</p>

    <p><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p>

    <p><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</p>

    <p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p>

    <p><strong>是否提供广播或多播服务</strong>：<strong>TCP 只支持点对点通信</strong>，<strong>UDP 支持一对一、一对多、多对一、多对多</strong>；</p>

    </p>
  </div>

  <div class="section" id="section5">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>三握三挥</h2>
    <p>
    <p><strong>TCP是面向连接的协议，在正式传输数据之前要做好两端之间的准备，需要发送总共三个报文来完成连接的建立。</strong></p>

    <h3>三次握手（Three-Way Handshake）</h3>

    <ol><li><strong>第一次握手（SYN）：</strong><ul><li><strong>客户端向服务器发送一个标志位</strong>（SYN seq = x），表示客户端请求建立连接。</li></ul></li><li><strong>第二次握手（SYN + ACK）：</strong><ul><li><strong>服务器接收到客户端的请求</strong>，<strong>向客户端发送一个确认（ACK = x + 1）</strong>和<strong>自己的标志位（SYN seq = y）</strong>。</li></ul></li><li><strong>第三次握手（ACK）：</strong><ul><li><strong>客户端接收到服务器的确认，向服务器发送一个确认</strong>（ACK = y + 1）。</li></ul></li></ol>

    <p><strong>为什么不是两次</strong>：为什么是三次而不是两次，因为是<strong>两次无法确认客户端的接收能力</strong>。客户端向服务端发送一个请求，服务端给出一个响应，这个时候就认为连接已经建立，这就是两次握手，服务端单方面的认为连接已经建立，但是客户端在发送一个请求之后就再也不管了，不管服务端是否响应，客户端都不再做出反应。<strong>TCP是面向连接</strong>的，这个连接是<strong>面向连接双方</strong>的，<strong>只有两次握手，只有服务端单方面的认为连接成功。</strong></p>

    <p><strong>为什么不是四次</strong>：三次就可以完成你对我和我对你之间连接的确认，次数更多只是资源的浪费。</p>

    <h3>四次挥手（Four-Way Handshake）</h3>

    <p><strong>TCP的四次挥手是为了终止一个TCP连接，作为客户端和服务端需要总共发送四个报文用来确认连接已经断开</strong></p>

    <ol><li><strong>第一次挥手（FIN）：</strong><ul><li><strong>当客户端或服务器某一方决定关闭连接</strong>时，<strong>发送一个关闭请求给对方</strong>。这里以客户端发送关闭请求为例。</li></ul></li><li><strong>第二次挥手（ACK）：</strong><ul><li><strong>接收到关闭请求的一方发送一个确认（ACK）给对方。</strong></li></ul></li><li><strong>第三次挥手（FIN）：</strong><ul><li><strong>服务端接收到关闭请求后，决定也关闭连接，向发起关闭请求的一方发送一个关闭请求</strong>（FIN）。</li></ul></li><li><strong>第四次挥手（ACK）：</strong><ul><li><strong>客户端接收到关闭请求后发送一个确认（ACK）给对方</strong>。</li><li>这个时候连接关闭。</li></ul></li></ol>

    <p>主要涉及到 <strong>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</strong></p>

    <p>因为<strong>服务器收到客户端断开连接的请求时，可能还有一些数据没有发完</strong>，这时<strong>先回复 ACK</strong>，<strong>表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</strong></p>

    </p>
  </div>

  <div class="section" id="section6">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>HashMap添加元素</h2>
    <p></p>
  </div>
</div>
</body>
</html>